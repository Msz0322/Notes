## Render Tree后

- 浏览器会先获取 DOM 树并依据样式将其分割成多个独立的渲染层。
- CPU 将每个层绘制进绘图中。
- 将位图作为纹理上传至 GPU（显卡）绘制。
- GPU 将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU 就不需要对其进行重绘）
- 并复合多个渲染层最终形成我们的图像。
- 从上面的步骤我们可以知道，布局是由 CPU 处理的，而绘制则是由 GPU 完成的。

## 垃圾回收（GC）

### 标记清除（主流）

1. 【标记】从根节点，遍历所有对象，标记可达的对象，未被标记的视为不可达。
2. 【回收】标记完成后，清除所有不可达的对象。
3. 【整理】频繁回收对象后，主垃圾回收器会产生内存碎片，副垃圾回收器并不会产生，是由于副垃圾回收器分配空间是有序排列的。

## 新生代和老生代

**老生代回收器**负责**长久对象**
**新生代回收器**负责**临时对象**

长久对象：全局变量，如window、DOM
临时对象：存活时间短、块级作用域中变量、应及时回收

老生代：内存空间1400MB
新生代：From、To空间各16MB，使用广度优先扫描

晋升：临时对象经历5次以上垃圾回收，或内存使用占比过大时会晋升为长久对象。

### 何时触发

- 分代收集：多回收新生代，少回收老生代。
- 增量收集：执行一小块时运行。
- 闲时收集：浏览器空闲时运行。

### 排查

1. layers面板，观察渲染层的数量和层级。
2. memory面板，记录内存快照，对比内存空间占用。
3. performance monitor面板，实时观察性能数据变化。
4. performance面板录屏，观察Js Heap、GPU Memory、Documents、Nodes、Listeners，和FPS下降时，各耗时操作。
5. rendering面板
   1. Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示
   2. Layer borders：用高亮边界突出我们页面中的各个渲染层
   3. FPS meter：观察GPU占用率

## 优化总结
1. 资源
   1. 雪碧图、webp、小图base64。
   2. 图片懒加载、资源预加载。
2. 渲染机制
   1. css放头部、js放底部。由于script标签，async异步加载完成后执行，规范要求defer异步加载后在DomContentLoaded事件触发前执行，但实际不是，async > defer
3. 渲染层
   1. 将容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离。
   2. 复合层创建标准中有一条，元素有一个 z-index 较低且包含一个复合层的兄弟元素(也就是该元素在复合层上面渲染)
4. DOM
   1. DOM离线操作，合并操作。
5. GC
   1. 由于GC执行时，会阻塞脚本运行，所以需要减少GC触发，减少临时变量的使用。
6. 实例
   1. 使用时提供创建方法，并能够初始化一定数量，提供获取实例、回收、释放等方法。
7. 构建
   1. dll、hard-source通过缓存形式，加速构建过程。
   2. terser压缩js、css-mini压缩css，降低代码体积。
   3. parallel开启多进程编译。