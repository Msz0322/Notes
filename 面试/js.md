#  面试知识点汇总：JS

参考自:
- https://juejin.im/post/6844904070579240974#heading-15

## Q：原型链

|   对象   |     属性      |    属性名    | 描述                                                  |
| :------: | :-----------: | :----------: | ----------------------------------------------------- |
| 构造函数 |   prototype   | 显式原型属性 | 函数的prototype原型属性 指向 原型对象，默认为空Object |
|   实例   | \_\_proto\_\_ | 隐式原型属性 | 在实例化创建时产生，值等于构造函数的prototype的值     |

Ep:

instance1.\_\_proto\_\_ = instance1.construtor.prototype = instance2

> 引擎创建了Object.prototype，Function.prototype
> 
> person.\_\_protp\_\_ => Function.\_\_protp\_\_=> Object.\_\_protp\_\_=> null

**由\_\_protp\_\_属性组成的链，就叫做原型链**

那么，原型链的主要作用是什么？
- 实现继承：如果没有原型链，无法关联每个对象。
- 属性查找：先从当前实例对象上查找，要是没找到，沿\_\_proto\_\_往上查找
- 实例类型判断：判断实例

## Q：基本数据类型和引用数据类型在内存上有什么区别？

|   类型   |  栈内存  | 堆内存 |
| :------: | :------: | :----: |
| 基本类型 |  存储值  |   x    |
| 引用类型 | 存储内存地址 | 存储值 |

基本类型：存储在栈内存中，因为基本类型的大小是固定的。

引用类型：存储在堆内存中，因为引用类型的大小不固定，栈内存存储内存地址

## Q：typeof 和 instanceof 有什么区别

1. typeof(a) 用于返回值的类型

2. instanceof判断对象是否是目标实例,根据\_\_proto\_\_向上查找。

## Q：toString 和 valueOf 有什么区别

在 Object 中存在这个两个方法，继承Object的对象可以重写方法。这两个方法主要用于隐式转换

```js
1 + '1' // 11 ：整型 1 被转换成字符串 '1'，变成了 '1' + '1' = '11'
2 * '3' // 6  ：字符串 '3' 被转换成整型 3 ，变成了 2 * 3 = 6
```

当这两个函数同时存在时候，会先调用 **valueOf** ，若返回的不是原始类型，那么会调用 **toString** 方法，如果这时候 **toString** 方法返回的也不是原始数据类型，

那么就会报错:**TypeError: Cannot convert object to primitive value**

## Q:垃圾回收机制

为什么需要垃圾回收：因为对象需要占用内存，而内存资源是有限的。

js 会周期性的对不在使用的对象销毁，释放内存，关键点就在于怎么识别哪些对象是垃圾。

垃圾对象：对象没有被引用，或者几个对象形成循环引用，但是根访问不到他们，这些都是可回收的垃圾。

垃圾回收的两种机制：标记清除和引用计数

### 标记清除法
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

比如说函数中声明了一个变量，就做一个标记，当函数执行完成，退出执行栈，这个变量的标记就变成已使用完。

目前主流浏览器采用的是这个策略

### 引用计数
跟踪每个值被引用的次数，声明一个变量后，这个变量每被其他变量引用一次，就加 1 ，如果变量引用释放了，就减 1，当引用次数为 0 的时候，对象就被清理。但这个有个循环引用的弊端，所以应用的比较少。

### 垃圾收集的性能优化

1. 分代回收，对象分成两组，新生带、老生带，
2. 增量回收
3. 空闲时间回收

### 编码可以做的优化

1. 避免重复创建对象。
2. 在适当的时候解除引用，是为页面获的更好性能的一个重要方式。
3. 全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。
